---
layout:     post
title:      "オブジェクト指向UIデザイン"
date:       2024-06-09 00:00:00 +0900
categories: it memo
---

![thumbnail](/assets/2024-06-09-object-oriented-user-interface-design/thumbnail.png)

※本ブログの目的と内容[^1]、著作者の方へ[^2]

[^1]: 本ブログは「本を読み、理解した内容の備忘録（自分用）」を目的としている。重要なアイディアを昇華させ、自分の言葉でまとめるように努めている

[^2]: 内容に不快を感じ、ブログの取り下げを希望される著作者の方は、個別にご連絡いただけると幸いに思う


## デザイン

#### 人類の知能の発達要因
人類は、**自身で作成した道具に作用され**、その知能が発達してきた。

##### モードレスな（抽象度の高い）道具による相互作用
抽象度の高い道具（ナイフ：高、ピーラー：低）は、ユーザ次第（用途のアイディア・スキルの向上）で利便性が広がる。
**モードレスな道具**は、**ユーザの変化**で意味性を高めるという意味で、**人と道具の相互発展**をポジティブな方向に促す。
これが、モーダルなタスク指向デザインではなく、モードレスなオブジェクト指向デザインを行うことの意義。

#### 一貫して作用する「原理」を備える
「万人に合わせたデザイン」ではなく、「**万人が自ら合わせられるデザイン**」が良いデザイン。
要求ごとに愚直に対応すると、典型的なタスク指向デザインになる。
「対象・行えるアクション・その結果」が見えれば、ユーザはその道具の役割と機能を自ら発見し、仕事を組み立てられる。

![task-and-design](/assets/2024-06-09-object-oriented-user-interface-design/task-and-design.png)

#### 使いづらい事業者目当てのデザイン
ユーザ目当てではなく、事業者目当てで設計されたソフトウェアは使いにくくなる。
**ユーザは自身の目当てを覆い隠され**、ソフトウェアを使って何かをするのではなく、ソフトウェアによって何かをさせられている。


## 操作モデル
なぜ私たちはオブジェクト指向に着目するのか。
いろいろな「指向」がある内のひとつというわけでは決してない。
「オブジェクト指向で作る」のではなく、在るがままに在るようにして作れば「それがオブジェクト指向」なのです。

### オブジェクト指向UI
オブジェクト（ユーザの**関心対象の構造的概念（メンタルモデル）**であり操作対象）を手がかりに設計されたUIのこと。
「**モードレス**（モードがない）」に本質的な優位性がある。

#### オブジェクト指向とは
システムをデザインする際に主体（知覚する者）ではなく**客体（知覚される物）**をモデル化することに本質がある。
ソフトウェア世界の中に対象（オブジェクト）が存在し、そこへ何かしらのアプローチを起こす。
オブジェクトは**自律的にそのアプローチへ反応**し、自分自身を変化させたり、他のオブジェクトにアプローチを起こす。
このイメージが、**抽象的なプログラミングと具象的なUIの間で一貫したパラダイム**を作っている。

##### オブジェクト指向UIの原則
- オブジェクトを知覚でき直接的に働きかけられる
- オブジェクトは自身の性質と状態を体現する
    - ユーザが状態を把握し、次の操作を判断する
- **オブジェクト選択→アクション選択** の操作順序
    - GUIの本当の特徴はこの操作構文にある
- すべてのオブジェクトがお互いに強調しながらUIを構成する

#### GUI
GUIは「グラフィック」に「オブジェクト指向UIの原則」を適用したものであり、そのために使いやすい。
コンピュータ内の情報を物のように感じさせ（メンタルモデルをコンピュータ内で模式的に再現し）、日常生活の作業と同じ感覚で扱えるようにする。
それらに対して自由に働きかけながら目的（タスク）を達成できるようにする。

優れたGUIに対してユーザが「マニュアルを読まなくても使える」と感じるのは、そもそも決まった手順がないため。
手順がなく、ユーザが好きな方法で目的に向かっていける。これがGUIの根本にあるモードレス性。

##### Sketchpad・Smalltalk
単なる計算機ではなく、人が試行錯誤しながら目的を達成していくためのクリエイティブな道具として、コンピュータを再定義した。
SmalltalkのUIが「モードレス」であることを重視していたのは、PCに求められる「誰でも使える」ことを実現するための根本的な条件だったから。
UIの表現が空間的なマッピングを利用したオブジェクト指向であることと、操作が非順序的でモードレスであることの間には、相互に強い必然性がある。

### タスク指向UI
CLIのように動詞を起点として設計されたUIのこと。
「**モーダル（モードがある）**」であり、操作の自由度を奪い、余計な手続きを増やす。

##### 問題点
オブジェクトがタスクの中に閉じ込められ、タスクを開始しないと何があるのかが見えてこない（アプリで扱う情報とその全体像がはっきりしない）。
これを「情報なき同意（その選択が目的が達成されるかわからないまま先へ進まなければならない状況）」と呼ぶ。
操作の流れの中にモードがあると、そのシステムは使いにくくなる。
たとえばある操作を行うとそれに従って次に行える操作が限定される場合、それはモードに入ったことになる。
タスク指向の操作手順はモーダルであり、これをGUIに持ち込むと使いにくくなる。
モーダルダイアログはユーザの仕事を中断し、特定の入力操作を強要する。

#### ドナルド・ノーマン

> モードエラーは、一つのスイッチが二つの役割を果たしている装置ではいつでも生じうる。

##### ボタンが少ないためにモードが生まれる
ボタンが増えたとしても、それぞれがモードを持たずひとつの機能に割り当てられれば、混乱は少ない。

##### タスク指向UIに陥る原因
**ユーザのタスクをコンピュータが効率よく代行する**ことがデザインの目的であると認識されているため。

### オブジェクト指向UIとタスク指向UI

| オブジェクト指向UI      | タスク指向UI              |
|:----------------|:---------------------|
| 名詞 → 動詞         | 動詞 → 名詞              |
| オブジェクト（名詞）が手がかり | タスク（動詞）が手がかり         |
| モードレス           | モーダル                 |
| 探索・創意工夫         | オブジェクトの選択不要・定型の入力手続き |

手続き型プログラミングの構文では、Verb（動作）→Object（対象物）の順に記述するのが普通。
```php
strtoupper('hello');
```

オブジェクト指向プログラミングの構文では、Object（対象物）→Verb（動作）という記述順序になる。
```javascript
'hello'.toUpperCase();
```


## オブジェクト指向UIの設計

### 基本ステップ
どのレイヤーから着手しても良い。各レイヤーを行きつ戻りつしながらデザインする。
各レイヤーを行きつ戻りつ検討する作業は、複雑な構造体に有効性を与えるために必要な取り組み。
インタラクションやプレゼンテーションがユーザの要求を満たしていない場合、モデリングを再検討する。
情報量が多く複雑なアプリほど、目に見える形にしてみて得られる気づきがある。

プレゼンテーションは最優先に検討されるべきであり、その裏にある構造は
プレゼンテーションとモデルの間の整合性をとるためのものに過ぎない。
ユーザにはUIがシステムそのものであり、先にあるべきUIがモデリングされるべき。

##### ソフトウェアデザインのレイヤー
![software-design-layer](/assets/2024-06-09-object-oriented-user-interface-design/software-design-layer.png)

##### デザイナーのアブダクションライン
![abduction-line](/assets/2024-06-09-object-oriented-user-interface-design/abduction-line.png)

### モデル｜オブジェクトの抽出
ユーザのメンタルモデルや業務中にどのような概念が存在するかを調べ、ユーザの操作対象となるオブジェクトを提起する。
業務を行っているユーザ自身があまり明確に意識していない、けれど情報システムを論理的に構成する上では重要になる概念を、うまく発見しなければいけない。
オブジェクトはプログラムの中で概念的な処理の単位として定義される。
対象ドメインの範囲が広いか、範囲が漠然として場合は、アプリでサポートするドメインのスコープを決める。

#### オブジェクトの抽出ステップ
レイアウトからオブジェクトを定義するという方向もある。

1. **タスク**を書き出す
2. 「**名詞**」を抽出する
   - タスクの文言から名詞を探す
   - ユーザの関心対象となる概念が何かを考える
   - オブジェクトには「もの」的なものもあれば、「こと」的なものもある
   - 一見同じように見えるものを異なるオブジェクトとして抽出するためには、厳密に命名する必要がある。
     - 設置されている遊具 と　遊具の種類
     - 仕入れ と 仕入れの明細
3. 「名詞」とそれらの**関係**を抽出する
   - 名詞同士の関係を整理する 
4. 「名詞」を汎化し、**粒度**を揃える
   - 上位概念に昇華し過ぎたと思ったら戻ってみる
5. 「名詞」の関係性をつなげ、**オブジェクトを特定**する
   - 名詞同士をつなげ、ネットワーク状にする
6. 「**メイン**オブジェクト」を特定する
   - 主要なもの（メインオブジェクト）とそうでないもの（サブオブジェクト）に分ける
   - 人の持つ優先度の判断能力に委ねる
   - 関連を表す線の多さを目安にする  
   ![selecting-main-object](/assets/2024-06-09-object-oriented-user-interface-design/selecting-main-object.png)
7. メインオブジェクトの多重性を特定する
   - 多重になるオブジェクトに「*」を付ける
8. メインオブジェクトに付随するオブジェクトを**プロパティ**とする
9. タスクからアクションを見つける
   - メインオブジェクトとアクションを結び付ける
   - 「〜を確認する」というタスクは、そのオブジェクトを表示すれば済む

![modeling](/assets/2024-06-09-object-oriented-user-interface-design/modeling.png)

##### オブジェクトの特性
- 数えられる名詞として表せる
- 同種の集合として管理され得る
- 共通のアクションを持っている

ただし、動詞的な概念や属性的な要素でもオブジェクトになることもある。

##### アクションのオブジェクト化
オブジェクト指向UIにおいて、プロパティとアクションはオブジェクトに付随するもの。
あるオブジェクトに関するタスクが、そのオブジェクトのプロパティから自動的に導出できる情報を参照することである場合は、
その導出ロジックを組み込んだオブジェクトを作り、それをプロパティにする。
「BMIを計算する」というアクションではなく、「BMI」というプロパティとして表示するなど。

### インタラクション｜ビューとナビゲーションの検討
モデルとプレゼンテーションをつなぐためのメカニズム。

#### ビュー
ユーザが画面上で実際に目にするひとまとまりの情報表示領域のこと。

ひとつのオブジェクトは複数のビューで扱われる。
同一オブジェクトが場面に応じて姿を変え、異なる場面や情報の詳細度で表象される。
メッセージのアイコン、一覧、内容などが、ユーザにとって意味のある呼び出し関係としてつながれ、UIを構成する。

ビューの表現には「コレクション」と「シングル」のふたつがある。
オブジェクトごとにコレクションビューとシングルビューを用意する。
シングルビュー・コレクションビューそれぞれ省略する場合はある。

##### コレクション
ひとつのビューの中に同種のオブジェクトを複数並べて表示する。
オブジェクトが持つ属性の重要なものだけを表示する。

##### シングル
ひとつのビューでオブジェクトひとつ分を表示する。

##### コントローラーの機能
コントローラーとは一般的に、複数のオブジェクトを制御する役割を担ったオブジェクトを指す。

１つの画面や１つのペインについて、その領域のビューを制御するためのコントローラーオブジェクトを設ける。
そのようなコントローラーは、ユーザからの入力を受け取って、モデルを更新し、
そしてその結果をビューの状態の変化として反映する際の制御を行う。

コレクションビューにおいては、表示する項目をデータベースから取り出す条件や、
一覧における現在の選択状態が、コントローラーのプロパティとして保持される。
項目を新規に追加したり、既存の項目を削除したりするアクションは、コントローラーが実行する。

#### ナビゲーション

##### オブジェクト間ナビゲーション
多重性を手がかりに、ナビゲーションとしての呼び出し関係を考える。

メインオブジェクト同士のつながりと多重性から参照可能性を導き出し、呼び出し関係を定義する。

あるオブジェクトからそれに直接関係している他のオブジェクトを呼び出して見たいと考える。
矢印線がナビゲーションの遷移の方向を表す。

##### ルートナビゲーション
ユーザがルートナビゲーションを選択すると、そのオブジェクトのコレクションビューが表示される。
オブジェクトを並べることで、それがアプリの基本的な情報構造になる。

アプリを「機能」ではなく「もの」が並んでいるイメージで捉える。
ルートナビゲーションのアイコンをアプリの中で一貫して用いることで、ユーザは情報構造全体の適切なメンタルモデルを持てる。

ユーザがアプリを使う際に、思考の起点となりそうなオブジェクトを選定する。
全体から考えて特に重要なオブジェクトを選ぶ。

項目名に、「〜システム」や「〜一覧」、「〜管理」などは冗長なので不要。

### プレゼンテーション｜レイアウトパターンの適用
すでに一般化しているパターンを用いる。

メインオブジェクトの一覧を早い段階で見せる。
「オブジェクト選択→アクション選択」という操作構文をできるだけアプリ全体で踏襲する。
一覧でユーザが項目を選択すると、情報の階層をドリルダウンして、選択したオブジェクトの詳細情報が表示される。
詳細情報が表示されているビュー／画面では、通常、オブジェクト単体に対するアクションが用意されている。
特定のビューや画面は「機能」を表す単位ではなく、「対象」を表すものになる。

#### ルートナビゲーション
スマホであれば下や開閉式、デスクトップであれば上や左に配置されることが多い。

#### ペイン
コレクション・シングルビューを１画面に表示するパターンは、スマホなどの画面面積が少ない場合に向いている。

画面を複数ペインに区切る「シングルウィンドウ」式のレイアウトよりも、
コレクション・シングルビューを１画面で表示して遷移する方式の方が、
オブジェクトの呼び出し関係を作る上では柔軟性が高い。

各ビューをペインとして一つの画面内に並べて構成する。
ペイン間のインタラクションには方向性をもたせる。

- 左で操作した結果が右に反映される
- 上で操作した結果が下に反映される

![desktop-mobile-layout](/assets/2024-06-09-object-oriented-user-interface-design/desktop-mobile-layout.png)

画面単位を変えることで、同一UIをデスクトップとモバイルに対応させられる。

#### コレクションビュー
コレクションビューの表示形式は、アプリの有効性を高める上で非常に重要な役割を果たし、アプリの性質をそのまま代弁する。
コレクションビューの表示形式は、オブジェクトへの視点を反映する。

| パターン | 特徴                 |
|:-----|:-------------------|
| 1項目1行の1次元リスト | 多くの項目を一覧させるのに適している |
| 1項目複数行の1次元リスト | リスト上である程度の情報を表示できる |
| 1項目複数行の1次元リスト（高さ可変） | SNSなどでよく用いられる      |
| サムネールのグリッド | イメージを強調するタイプ       |
| マッピング | カレンダーや地図など、2次元上にマッピングするタイプ |

一覧画面に追加と削除の機能を持たせたり、新規追加用の画面と更新用の画面を共通化することは、
データベースへのCRUD機能を提供する情報システムの定石。

##### フィルタリング
全項目を一度に表示すると、数が多すぎて目的の項目が見つけづらくなる場合がある。
フィルタリング機能をコレクションビューに組み込むことで、タスクに準じた条件ですぐに表示を絞り込める。

#### シングルビュー
アプリの機能性、ユーザのメンタルモデル、操作のコンテクストに合わせて変わる。

| パターン | 特徴                               |
|:-----|:---------------------------------|
| 他のオブジェクトのコレクションの一部を表示する | ユーザにとって重要と思われるいくつかのコレクションを先出しする  |
| 他のオブジェクトのコレクションを強調する | すべての他のオブジェクトを表示することで、コレクションが強調される |
| 他のオブジェクトのコレクションだけを表示する | フォルダとファイルのように、別のオブジェクトのコレクションが中に入っているような表現になる |

対象となるオブジェクトの近くに、そのオブジェクトに対して実行可能な一連のアクションボタンを、一貫した表現で並べる。

##### Createアクションのパターン

| パターン         | 特徴                   |
|:-------------|:---------------------|
| ブランクパターン     | 空のアイテムが作成される         |
| パラメータパターン    | モーダルが現れて、必要なパラメータを入力 |
| プレースホルダーパターン | 常に新規作成用のプレースホルダーを表示  |
| セーブアズパターン | 既存のアイテムをコピーして別名保存    |
| テンプレートパターン | テンプレートを選んで新規作成       |
| マスターパターン | マスターから新規作成           |
| ワンタイムモードパターン | 新規作成モードに入る |
| ガッツパターン | デフォルトで作成 |

##### Deleteアクションのパターン

| パターン         | 特徴                   |
|:-------------|:---------------------|
| モーダルコンファームパターン | モーダルで確認を促される |
| アンドゥアブルパターン | 「戻る」で取り消せる |
| モードレスコンファームパターン | 確認がモードレスに表示 |

##### Updateアクションのパターン

| パターン         | 特徴                       |
|:-------------|:-------------------------|
| モーダルエディットパターン | 参照と編集がモードで分かれ、「保存」ボタンがある |
| モードレスエディットパターン | 常に編集可能で、自動保存 |

#### モードレスにする方法

##### アクションを分割する
アクションを複数の「１ストローク即時実行」に分割する。

モードレスなUIとは、アクションの前後にモードがないということ。
アイドル状態からモードレスに「対象選択」ができ、モードレスに「アクション選択」ができ、
その後に追加の入力が求められずモードレスなままアクションが完了すること。
「１ストローク即時実行」ということ。

##### サブミットボタンをなくす
操作をモードレスにするためのまた別なアプローチは、サブミットボタンをなくすこと。

プロパティを個別に反映させるとオブジェクトの状態に問題が生じる場合には、
フィールド間の整合性が保たれるように自動で他のフィールドを変更するようにする。
これをデータバインドと言う。

データバインドを実装することができない、もしくはフィールド間の整合性を自動的に保つような処理を加えられない場合にのみ、
モーダルなサブミット式を採用する。


## タスク
タスクを定義し、そこからUIをデザインしても、タスクの複雑な特徴から、デザインも必要以上に複雑なものになってしまう。
単純化すると、タスクはオブジェクトとアクションの組み合わせになる。

##### タスクの特徴
- 粒度がさまざま ... 厳密に境界を定義できない
- 増える
- 変わる
- やり終えないとわからない ... 行動しながら考えたりする

#### タスクの反映

| 反映先         | 補足                                                                     |
|:------------|:-----------------------------------------------------------------------|
| コンテンツ       | コンテンツはあくまでも代表的なタスクを限定的に説明するもの。ヘルプ（タスクに応じた情報）やプロモーション（タスクに従ったソリューション）など |
| 表示形式        | 特定のプロパティに関連したタスクの場合、そのプロパティを強調する表示形式を用意する。                             |
| アクション       | すでに抽出済みのオブジェクトのアクションのバリエーションとして扱う。                                     |
| 初期値         | 良い初期値はユーザの作業効率を大きく引き上げる。                                               |
| テンプレート      | ユーザはテンプレートからタスクの作業文脈を得る。                                               |
| フィルタリンググループ | タスクを意識したフィルタリンググループを用意する。最も重要なフィルタリンググループであれば、初期状態で選択される。              |

